<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>To the Moon üí´</title>
  <meta name="description" content="A tiny 3D moon with sweet messages." />
  <style>
    :root { --bg:#05060a; --fg:#eaeefc; --muted:#9aa4b2; --accent:#7aa2ff; }
    html,body { height:100%; margin:0; background: radial-gradient(1200px 800px at 70% 10%, #0b0f1a 0%, #05060a 40%, #03040a 100%); color:var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji"; }
    #scene { position:fixed; inset:0; }
    .hud { position:fixed; inset:0; pointer-events:none; display:grid; place-items:center; padding:24px; }
    .card { pointer-events:auto; backdrop-filter: blur(8px); background: rgba(12,14,20,.45); border:1px solid rgba(255,255,255,.08); border-radius:20px; padding:18px 20px; box-shadow: 0 20px 60px rgba(0,0,0,.35); max-width: 560px; text-align:center; transition:.35s ease; }
    .card.hide { opacity:0; transform: scale(.98); pointer-events:none; }
    h1 { margin:0 0 6px; font-weight:700; letter-spacing:.2px; font-size: clamp(22px, 2.8vw, 32px); }
    p { margin:6px 0 14px; color:var(--muted); line-height:1.5; font-size: clamp(14px, 1.8vw, 16px); }
    .row { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
    .btn { pointer-events:auto; appearance:none; border:1px solid rgba(255,255,255,.12); background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02)); color:var(--fg); padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:600; transition: .2s transform, .2s opacity, .2s border-color; }
    .btn:hover { transform: translateY(-1px); border-color: rgba(255,255,255,.25); }
    .btn.primary { background:linear-gradient(180deg, rgba(122,162,255,.4), rgba(122,162,255,.15)); border-color: rgba(122,162,255,.55); }
    .corner { position:fixed; bottom:14px; right:14px; opacity:.7; font-size:12px; letter-spacing:.3px; }
    .tip { position:fixed; top:12px; left:12px; opacity:.75; font-size:12px; }
  </style>
</head>
<body>
  <canvas id="scene" aria-label="Interactive 3D moon"></canvas>

  <div class="hud" aria-live="polite">
    <div class="card" id="card">
      <h1>Hey, I got you the Moon üåô</h1>
      <p id="msg">Tap the moon or the button to reveal messages that <em>stick to the moon</em>.</p>
      <div class="row">
        <button class="btn primary" id="reveal">Reveal a message</button>
        <button class="btn" id="reset">Reset</button>
      </div>
    </div>
  </div>

  <div class="tip">Drag to rotate ¬∑ Scroll to zoom ¬∑ Click the moon to cycle</div>
  <div class="corner">Made with ‚ù§Ô∏è + Three.js</div>

  <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>

  <script>
  // ===== Basic setup =====
  const canvas = document.getElementById('scene');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  function size() { renderer.setSize(window.innerWidth, window.innerHeight); }
  size();

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 200);
  let camZ = 3.2; // manual zoom control
  camera.position.set(0, 0.6, camZ);

  // ===== Lights =====
  const ambient = new THREE.AmbientLight(0xffffff, 0.35); scene.add(ambient);
  const keyLight = new THREE.PointLight(0xffffff, 1.2, 0, 2); keyLight.position.set(4, 2, 3); scene.add(keyLight);
  const rimLight = new THREE.PointLight(0x9bb7ff, 0.45, 0, 2); rimLight.position.set(-3, -1.5, -2.5); scene.add(rimLight);

  // ===== Stars background =====
  function makeStars(count = 1200) {
    const g = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    for (let i = 0; i < count; i++) {
      const r = THREE.MathUtils.randFloat(20, 80);
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(THREE.MathUtils.randFloatSpread(2));
      pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
      pos[i*3+1] = r * Math.cos(phi);
      pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
    }
    g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const m = new THREE.PointsMaterial({ size: 0.08, color: 0x9fb6ff });
    return new THREE.Points(g, m);
  }
  scene.add(makeStars());

  // ===== Moon =====
  const R = 1; // moon radius
  const moonGroup = new THREE.Group();
  scene.add(moonGroup);

  const loader = new THREE.TextureLoader();
  const moonTex = loader.load('https://threejs.org/examples/textures/planets/moon_1024.jpg');
  const bumpTex = loader.load('https://threejs.org/examples/textures/planets/moon_bump.jpg');

  const moonGeo = new THREE.SphereGeometry(R, 96, 96);
  const moonMat = new THREE.MeshStandardMaterial({ map: moonTex, bumpMap: bumpTex, bumpScale: 0.035, roughness: 1.0, metalness: 0.0 });
  const moon = new THREE.Mesh(moonGeo, moonMat);
  moon.castShadow = false; moon.receiveShadow = false;
  moonGroup.add(moon);

  // Soft halo glow
  const glowGeo = new THREE.SphereGeometry(R*1.12, 48, 48);
  const glowMat = new THREE.MeshBasicMaterial({ color: 0x445bff, transparent: true, opacity: 0.08, blending: THREE.AdditiveBlending, side: THREE.BackSide });
  const glow = new THREE.Mesh(glowGeo, glowMat);
  moonGroup.add(glow);

  // ===== Messages attached to the moon =====
  const messages = [
    "When I miss you, I look up at this moon.",
    "Same moon, same sky ‚Äî always us.",
    "You are my favorite universe.",
    "To the moon and back (and back again).",
    "I love you in every phase."
  ];
  let messageIndex = -1;
  let labelSprite = null; // current label
  let pin = null;         // small glowing dot on the surface

  function makeLabelTexture(text){
    const pad = 18; const fs = 18; const lh = 26;
    const lines = text.split(/
/);
    const w = Math.max(...lines.map(t=> t.length)) * (fs*0.62) + pad*2;
    const h = pad*2 + lh*lines.length;
    const cvs = document.createElement('canvas');
    cvs.width = Math.ceil(w); cvs.height = Math.ceil(h);
    const ctx = cvs.getContext('2d');
    ctx.fillStyle = 'rgba(12,14,20,0.7)';
    roundRect(ctx, 0,0, w,h, 12); ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 1; roundRect(ctx, 0.5,0.5, w-1,h-1, 12); ctx.stroke();
    ctx.font = `${fs}px system-ui, -apple-system, Segoe UI, Roboto, Inter`;
    ctx.fillStyle = '#eaeefc';
    lines.forEach((t, i) => ctx.fillText(t, pad, pad + lh*(i+0.85)) );
    return new THREE.CanvasTexture(cvs);
  }

  function roundRect(ctx, x, y, w, h, r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y,   x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x,   y+h, r);
    ctx.arcTo(x,   y+h, x,   y,   r);
    ctx.arcTo(x,   y,   x+w, y,   r);
    ctx.closePath();
  }

  function showNextLabel(){
    messageIndex = (messageIndex + 1) % messages.length;
    const text = messages[messageIndex];

    // Remove previous label & pin
    if (labelSprite){ scene.remove(labelSprite); labelSprite.material.map.dispose(); labelSprite.material.dispose(); }
    if (pin){ scene.remove(pin); pin.geometry.dispose(); pin.material.dispose(); }

    // Pick a random point on the sphere front half (favor facing camera)
    const theta = Math.random()*Math.PI*2;
    const phi = THREE.MathUtils.randFloat(0.35*Math.PI, 0.65*Math.PI); // avoid poles
    const n = new THREE.Vector3(
      Math.sin(phi)*Math.cos(theta),
      Math.cos(phi),
      Math.sin(phi)*Math.sin(theta)
    );
    // ensure facing roughly the camera (z towards camera)
    if (n.z > 0) n.z *= -1;

    const surface = n.clone().multiplyScalar(R);
    const labelPos = n.clone().multiplyScalar(R + 0.35); // float a bit above

    // Small glowing pin on surface
    const pinGeo = new THREE.SphereGeometry(0.02, 16, 16);
    const pinMat = new THREE.MeshBasicMaterial({ color: 0x9bb7ff });
    pin = new THREE.Mesh(pinGeo, pinMat);
    pin.position.copy(surface);
    scene.add(pin);

    // Label sprite that always faces camera
    const tex = makeLabelTexture(text);
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: true, opacity: 0 });
    labelSprite = new THREE.Sprite(mat);
    const scale = 0.0085; // convert canvas px to world units
    labelSprite.scale.set(tex.image.width*scale, tex.image.height*scale, 1);
    labelSprite.position.copy(labelPos);
    scene.add(labelSprite);

    // Fade in
    const t0 = performance.now();
    const duration = 320;
    (function fade(){
      const a = Math.min(1, (performance.now()-t0)/duration);
      labelSprite.material.opacity = a;
      if (a < 1) requestAnimationFrame(fade);
    })();
  }

  // ===== HUD controls =====
  const card = document.getElementById('card');
  const msgP = document.getElementById('msg');
  document.getElementById('reveal').addEventListener('click', ()=>{
    card.classList.add('hide');
    showNextLabel();
  });
  document.getElementById('reset').addEventListener('click', ()=>{
    messageIndex = -1;
    if (labelSprite){ scene.remove(labelSprite); labelSprite = null; }
    if (pin){ scene.remove(pin); pin = null; }
    card.classList.remove('hide');
    msgP.textContent = 'Tap the moon or the button to reveal messages that stick to the moon.';
  });

  // ===== Click the moon to cycle labels =====
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let dragging = false, lastX = 0, lastY = 0;
  let rotX = 0, rotY = 0;

  window.addEventListener('pointerdown', (e) => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
  window.addEventListener('pointerup',   (e) => {
    if (dragging && Math.hypot(e.clientX-lastX, e.clientY-lastY) < 6){
      // treat as click
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects([moon]);
      if (hits.length){ card.classList.add('hide'); showNextLabel(); }
    }
    dragging = false;
  });
  window.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const dx = e.clientX - lastX; const dy = e.clientY - lastY;
    lastX = e.clientX; lastY = e.clientY;
    rotY += dx * 0.005; rotX += dy * 0.005; rotX = Math.max(-0.8, Math.min(0.8, rotX));
  });
  window.addEventListener('wheel', (e) => { camZ += e.deltaY * 0.0015; camZ = Math.max(1.6, Math.min(5.5, camZ)); }, { passive: true });

  // ===== Animate =====
  function tick(){
    requestAnimationFrame(tick);
    moon.rotation.y += 0.0006; glow.rotation.y -= 0.0002;
    moon.rotation.y += (rotY - moon.rotation.y) * 0.08;
    moon.rotation.x += (rotX - moon.rotation.x) * 0.08;
    camera.position.z += (camZ - camera.position.z) * 0.1;
    renderer.render(scene, camera);
  }
  tick();

  // ===== Resize =====
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); size();
  });
  </script>
</body>
</html>
